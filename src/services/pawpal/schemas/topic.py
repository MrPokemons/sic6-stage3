import secrets
import json
from typing import Annotated, List, Dict, Tuple, TypeAlias, Union, Optional, Literal
from typing_extensions import TypedDict
from pathlib import Path
from pydantic import BaseModel, Field

from datetime import datetime

from ....utils.typex import EmotionType


### Math
class MathUserAnswerExtraction(BaseModel):
    result: Optional[int] = Field(
        description="Extract the answer which is a number, it can be pure decimal or text and possible in another language, you must extract the number. if you can't find any, just set as None"
    )


class MathUserAnswer(BaseModel):
    raw_answer: Annotated[
        str, "user pure answer, then parse to extraction for real result"
    ]
    extraction: MathUserAnswerExtraction
    feedback: Optional[str] = None


class MathQnA(BaseModel):
    sequence: List[int]
    question: Optional[Annotated[str, "generated by LLM"]] = None
    is_answered: bool = False
    user_answers: List[MathUserAnswer] = []

    @property
    def answer(self):
        return sum(self.sequence)

    @property
    def latest_user_answer(self):
        if not self.user_answers:
            raise Exception(
                f"How does this suppose to happen? MathQnA hasn't been answered.\n{json.dumps(self, indent=2)}"
            )
        return self.user_answers[-1].extraction.result

    def is_correct(self, *, index: int = -1):
        index = min(len(self.user_answers) - 1, max(-1, index))
        if not self.user_answers or self.user_answers[index].extraction.result is None:
            return False
        return self.user_answers[index].extraction.result == self.answer

    @staticmethod
    def generate_sequence(length: int, min_val: int, max_val: int, *, no_sum_below_zero: bool = False) -> List[int]:
        if no_sum_below_zero:
            prelength = secrets.randbelow(length) + 1
            seq = [
                secrets.randbelow(max_val) + 1 for _ in range(prelength)
            ]
            postlength = length - prelength
            for _ in range(postlength):
                _v = secrets.randbelow(max_val - min_val + 1) + min_val
                seq.append(_v or 1)  # make sure no zero

            return seq

        seq = [
            secrets.randbelow(max_val - min_val + 1) + min_val for _ in range(length)
        ]
        return [_v or 1 for _v in seq]  # make sure no zero

    def fmt_sequence(self):
        seq_str = ", ".join(
            f"\"{'' if i == 0 else ('+' if i > 0 else '-')}{i}\"" for i in self.sequence
        )
        return f"[{seq_str}]"


### Guess The Sound
class GuessTheSoundUserAnswerExtraction(BaseModel):
    result: Optional[str] = Field(
        description="Extract the relevant words that you see, *BASED ON* the *LIST OF WORDS I PROVIDED* before. If you can't find any words you see, just set as None"
    )


class GuessTheSoundUserAnswer(BaseModel):
    raw_answer: Annotated[
        str, "user pure answer, then parse to extraction for real result"
    ]
    extraction: GuessTheSoundUserAnswerExtraction
    feedback: Optional[str] = None


class GuessTheSoundQnA(BaseModel):
    sound_path: Union[Path, str]
    answer: Annotated[str, "the object that makes the sound, e.g. animals, etc"]
    is_answered: bool = False
    user_answers: List[GuessTheSoundUserAnswer] = []

    @property
    def latest_user_answer(self):
        if not self.user_answers:
            raise Exception(
                f"How does this suppose to happen? GuessTheSoundQnA hasn't been answered.\n{json.dumps(self, indent=2)}"
            )
        return self.user_answers[-1].extraction.result

    def is_correct(self, *, index: int = -1):
        index = min(len(self.user_answers) - 1, max(-1, index))
        if not self.user_answers or self.user_answers[index].extraction.result is None:
            return False
        return self.user_answers[index].extraction.result.lower() == self.answer.lower()

    @staticmethod
    def randomize_gts_mapping(
        gts_mapping: Dict[str, List[Path]],
    ) -> Tuple[Annotated[str, "the object"], Annotated[str, "the sound path"]]:
        obj_ = secrets.choice(list(gts_mapping))
        obj_sound_path = secrets.choice(gts_mapping[obj_])
        return obj_, obj_sound_path


### Topic
class TopicParams(TypedDict):
    class TalkToMeParam(TypedDict):
        duration: Annotated[int, "in seconds"]

    class MathGameParam(TypedDict):
        total_question: int

    class GuessTheSoundParam(TypedDict):
        total_question: int

    class WouldYouRatherParam(TypedDict):
        duration: Annotated[int, "in seconds"]

    talk_to_me: TalkToMeParam
    math_game: MathGameParam
    guess_the_sound: GuessTheSoundParam
    would_you_rather: WouldYouRatherParam


class BaseExtractionTopic(BaseModel):
    overview: str = Field(
        description="Summarize the chat history, oriented to user's progress and achievement"
    )
    emotion: EmotionType = Field(
        description=f"Based on the user's response behaviour, analyze the user's overall emotion based on the provided list of emotions: {', '.join(EmotionType.__args__)}"
    )
    keypoints: List[str] = Field(
        description="List major event or behaviour for overall of the conversation, it can be achievement from the user or something that user need to know about themselve throughout the conversation"
    )


class TopicResults(BaseModel):
    class TalkToMeResult(BaseModel):
        class _Extraction(BaseExtractionTopic): ...

        type: Literal["talk_to_me"] = "talk_to_me"
        extraction: _Extraction
        start_datetime: datetime
        modified_datetime: datetime

    class MathGameResult(BaseModel):
        class _Extraction(BaseExtractionTopic): ...

        type: Literal["math_games"] = "math_games"
        extraction: _Extraction
        list_qna: List[MathQnA]
        start_datetime: datetime
        modified_datetime: datetime

    class GuessTheSoundResult(BaseModel):
        class _Extraction(BaseExtractionTopic): ...

        type: Literal["guess_the_sound"] = "guess_the_sound"
        extraction: _Extraction
        list_qna: List[GuessTheSoundQnA]
        start_datetime: datetime
        modified_datetime: datetime

    class WouldYouRatherResult(BaseModel):
        class _Extraction(BaseExtractionTopic): ...

        type: Literal["would_you_rather"] = "would_you_rather"
        extraction: _Extraction
        start_datetime: datetime
        modified_datetime: datetime


TopicResultsType: TypeAlias = Union[
    TopicResults.TalkToMeResult,
    TopicResults.MathGameResult,
    TopicResults.GuessTheSoundResult,
    TopicResults.WouldYouRatherResult,
]
